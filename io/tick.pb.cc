// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tick.proto

#include "tick.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace dat {
constexpr TickData::TickData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tradingday_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , instrumentid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , exchangeid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , exchangeinstid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , updatetime_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , actionday_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , lastprice_(0)
  , presettlementprice_(0)
  , precloseprice_(0)
  , preopeninterest_(0)
  , openprice_(0)
  , highestprice_(0)
  , lowestprice_(0)
  , volume_(0)
  , turnover_(0)
  , openinterest_(0)
  , closeprice_(0)
  , settlementprice_(0)
  , upperlimitprice_(0)
  , lowerlimitprice_(0)
  , predelta_(0)
  , currdelta_(0)
  , updatemillisec_(0)
  , bidprice1_(0)
  , bidvolume1_(0)
  , askprice1_(0)
  , askvolume1_(0)
  , bidprice2_(0)
  , bidvolume2_(0)
  , askprice2_(0)
  , askvolume2_(0)
  , bidprice3_(0)
  , bidvolume3_(0)
  , askprice3_(0)
  , askvolume3_(0)
  , bidprice4_(0)
  , bidvolume4_(0)
  , askprice4_(0)
  , askvolume4_(0)
  , bidprice5_(0)
  , bidvolume5_(0)
  , askprice5_(0)
  , askvolume5_(0)
  , averageprice_(0){}
struct TickDataDefaultTypeInternal {
  constexpr TickDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TickDataDefaultTypeInternal() {}
  union {
    TickData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TickDataDefaultTypeInternal _TickData_default_instance_;
}  // namespace dat
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_tick_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_tick_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_tick_2eproto = nullptr;

const uint32_t TableStruct_tick_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::dat::TickData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::dat::TickData, tradingday_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, instrumentid_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, exchangeid_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, exchangeinstid_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, lastprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, presettlementprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, precloseprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, preopeninterest_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, openprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, highestprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, lowestprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, volume_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, turnover_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, openinterest_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, closeprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, settlementprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, upperlimitprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, lowerlimitprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, predelta_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, currdelta_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, updatetime_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, updatemillisec_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidprice1_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidvolume1_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askprice1_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askvolume1_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidprice2_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidvolume2_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askprice2_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askvolume2_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidprice3_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidvolume3_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askprice3_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askvolume3_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidprice4_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidvolume4_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askprice4_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askvolume4_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidprice5_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, bidvolume5_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askprice5_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, askvolume5_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, averageprice_),
  PROTOBUF_FIELD_OFFSET(::dat::TickData, actionday_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::dat::TickData)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dat::_TickData_default_instance_),
};

const char descriptor_table_protodef_tick_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ntick.proto\022\003dat\"\224\007\n\010TickData\022\022\n\nTradin"
  "gDay\030\001 \001(\t\022\024\n\014InstrumentID\030\002 \001(\t\022\022\n\nExch"
  "angeID\030\003 \001(\t\022\026\n\016ExchangeInstID\030\004 \001(\t\022\021\n\t"
  "LastPrice\030\005 \001(\002\022\032\n\022PreSettlementPrice\030\006 "
  "\001(\002\022\025\n\rPreClosePrice\030\007 \001(\002\022\027\n\017PreOpenInt"
  "erest\030\010 \001(\002\022\021\n\tOpenPrice\030\t \001(\002\022\024\n\014Highes"
  "tPrice\030\n \001(\002\022\023\n\013LowestPrice\030\013 \001(\002\022\016\n\006Vol"
  "ume\030\014 \001(\005\022\020\n\010Turnover\030\r \001(\001\022\024\n\014OpenInter"
  "est\030\016 \001(\001\022\022\n\nClosePrice\030\017 \001(\002\022\027\n\017Settlem"
  "entPrice\030\020 \001(\002\022\027\n\017UpperLimitPrice\030\021 \001(\002\022"
  "\027\n\017LowerLimitPrice\030\022 \001(\002\022\020\n\010PreDelta\030\023 \001"
  "(\001\022\021\n\tCurrDelta\030\024 \001(\001\022\022\n\nUpdateTime\030\025 \001("
  "\t\022\026\n\016UpdateMillisec\030\026 \001(\005\022\021\n\tBidPrice1\030\027"
  " \001(\002\022\022\n\nBidVolume1\030\030 \001(\005\022\021\n\tAskPrice1\030\031 "
  "\001(\002\022\022\n\nAskVolume1\030\032 \001(\005\022\021\n\tBidPrice2\030\033 \001"
  "(\002\022\022\n\nBidVolume2\030\034 \001(\005\022\021\n\tAskPrice2\030\035 \001("
  "\002\022\022\n\nAskVolume2\030\036 \001(\005\022\021\n\tBidPrice3\030\037 \001(\002"
  "\022\022\n\nBidVolume3\030  \001(\005\022\021\n\tAskPrice3\030! \001(\002\022"
  "\022\n\nAskVolume3\030\" \001(\005\022\021\n\tBidPrice4\030# \001(\002\022\022"
  "\n\nBidVolume4\030$ \001(\005\022\021\n\tAskPrice4\030% \001(\002\022\022\n"
  "\nAskVolume4\030& \001(\005\022\021\n\tBidPrice5\030\' \001(\002\022\022\n\n"
  "BidVolume5\030( \001(\005\022\021\n\tAskPrice5\030* \001(\002\022\022\n\nA"
  "skVolume5\030+ \001(\005\022\024\n\014AveragePrice\030, \001(\002\022\021\n"
  "\tActionDay\030- \001(\tb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_tick_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tick_2eproto = {
  false, false, 944, descriptor_table_protodef_tick_2eproto, "tick.proto", 
  &descriptor_table_tick_2eproto_once, nullptr, 0, 1,
  schemas, file_default_instances, TableStruct_tick_2eproto::offsets,
  file_level_metadata_tick_2eproto, file_level_enum_descriptors_tick_2eproto, file_level_service_descriptors_tick_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_tick_2eproto_getter() {
  return &descriptor_table_tick_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_tick_2eproto(&descriptor_table_tick_2eproto);
namespace dat {

// ===================================================================

class TickData::_Internal {
 public:
};

TickData::TickData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:dat.TickData)
}
TickData::TickData(const TickData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tradingday_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tradingday_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tradingday().empty()) {
    tradingday_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_tradingday(), 
      GetArenaForAllocation());
  }
  instrumentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    instrumentid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_instrumentid().empty()) {
    instrumentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_instrumentid(), 
      GetArenaForAllocation());
  }
  exchangeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    exchangeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_exchangeid().empty()) {
    exchangeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_exchangeid(), 
      GetArenaForAllocation());
  }
  exchangeinstid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    exchangeinstid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_exchangeinstid().empty()) {
    exchangeinstid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_exchangeinstid(), 
      GetArenaForAllocation());
  }
  updatetime_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    updatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_updatetime().empty()) {
    updatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_updatetime(), 
      GetArenaForAllocation());
  }
  actionday_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    actionday_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_actionday().empty()) {
    actionday_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_actionday(), 
      GetArenaForAllocation());
  }
  ::memcpy(&lastprice_, &from.lastprice_,
    static_cast<size_t>(reinterpret_cast<char*>(&averageprice_) -
    reinterpret_cast<char*>(&lastprice_)) + sizeof(averageprice_));
  // @@protoc_insertion_point(copy_constructor:dat.TickData)
}

inline void TickData::SharedCtor() {
tradingday_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tradingday_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
instrumentid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  instrumentid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
exchangeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  exchangeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
exchangeinstid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  exchangeinstid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
updatetime_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  updatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
actionday_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  actionday_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lastprice_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&averageprice_) -
    reinterpret_cast<char*>(&lastprice_)) + sizeof(averageprice_));
}

TickData::~TickData() {
  // @@protoc_insertion_point(destructor:dat.TickData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TickData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tradingday_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  instrumentid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  exchangeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  exchangeinstid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  updatetime_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  actionday_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TickData::ArenaDtor(void* object) {
  TickData* _this = reinterpret_cast< TickData* >(object);
  (void)_this;
}
void TickData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TickData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TickData::Clear() {
// @@protoc_insertion_point(message_clear_start:dat.TickData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tradingday_.ClearToEmpty();
  instrumentid_.ClearToEmpty();
  exchangeid_.ClearToEmpty();
  exchangeinstid_.ClearToEmpty();
  updatetime_.ClearToEmpty();
  actionday_.ClearToEmpty();
  ::memset(&lastprice_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&averageprice_) -
      reinterpret_cast<char*>(&lastprice_)) + sizeof(averageprice_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TickData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string TradingDay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tradingday();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.TradingDay"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string InstrumentID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_instrumentid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.InstrumentID"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ExchangeID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_exchangeid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.ExchangeID"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ExchangeInstID = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_exchangeinstid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.ExchangeInstID"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float LastPrice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          lastprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float PreSettlementPrice = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          presettlementprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float PreClosePrice = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          precloseprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float PreOpenInterest = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          preopeninterest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float OpenPrice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          openprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float HighestPrice = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          highestprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LowestPrice = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          lowestprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 Volume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double Turnover = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          turnover_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double OpenInterest = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          openinterest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // float ClosePrice = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          closeprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float SettlementPrice = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          settlementprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float UpperLimitPrice = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          upperlimitprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LowerLimitPrice = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          lowerlimitprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double PreDelta = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          predelta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double CurrDelta = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          currdelta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string UpdateTime = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_updatetime();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.UpdateTime"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 UpdateMillisec = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          updatemillisec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float BidPrice1 = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          bidprice1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 BidVolume1 = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          bidvolume1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AskPrice1 = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          askprice1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 AskVolume1 = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          askvolume1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float BidPrice2 = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 221)) {
          bidprice2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 BidVolume2 = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          bidvolume2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AskPrice2 = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 237)) {
          askprice2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 AskVolume2 = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          askvolume2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float BidPrice3 = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          bidprice3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 BidVolume3 = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          bidvolume3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AskPrice3 = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          askprice3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 AskVolume3 = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          askvolume3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float BidPrice4 = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          bidprice4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 BidVolume4 = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          bidvolume4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AskPrice4 = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          askprice4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 AskVolume4 = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          askvolume4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float BidPrice5 = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          bidprice5_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 BidVolume5 = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          bidvolume5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AskPrice5 = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          askprice5_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 AskVolume5 = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          askvolume5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float AveragePrice = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          averageprice_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string ActionDay = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_actionday();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "dat.TickData.ActionDay"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TickData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dat.TickData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string TradingDay = 1;
  if (!this->_internal_tradingday().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tradingday().data(), static_cast<int>(this->_internal_tradingday().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.TradingDay");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tradingday(), target);
  }

  // string InstrumentID = 2;
  if (!this->_internal_instrumentid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instrumentid().data(), static_cast<int>(this->_internal_instrumentid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.InstrumentID");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_instrumentid(), target);
  }

  // string ExchangeID = 3;
  if (!this->_internal_exchangeid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_exchangeid().data(), static_cast<int>(this->_internal_exchangeid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.ExchangeID");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_exchangeid(), target);
  }

  // string ExchangeInstID = 4;
  if (!this->_internal_exchangeinstid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_exchangeinstid().data(), static_cast<int>(this->_internal_exchangeinstid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.ExchangeInstID");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_exchangeinstid(), target);
  }

  // float LastPrice = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lastprice = this->_internal_lastprice();
  uint32_t raw_lastprice;
  memcpy(&raw_lastprice, &tmp_lastprice, sizeof(tmp_lastprice));
  if (raw_lastprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_lastprice(), target);
  }

  // float PreSettlementPrice = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_presettlementprice = this->_internal_presettlementprice();
  uint32_t raw_presettlementprice;
  memcpy(&raw_presettlementprice, &tmp_presettlementprice, sizeof(tmp_presettlementprice));
  if (raw_presettlementprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_presettlementprice(), target);
  }

  // float PreClosePrice = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_precloseprice = this->_internal_precloseprice();
  uint32_t raw_precloseprice;
  memcpy(&raw_precloseprice, &tmp_precloseprice, sizeof(tmp_precloseprice));
  if (raw_precloseprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_precloseprice(), target);
  }

  // float PreOpenInterest = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_preopeninterest = this->_internal_preopeninterest();
  uint32_t raw_preopeninterest;
  memcpy(&raw_preopeninterest, &tmp_preopeninterest, sizeof(tmp_preopeninterest));
  if (raw_preopeninterest != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_preopeninterest(), target);
  }

  // float OpenPrice = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_openprice = this->_internal_openprice();
  uint32_t raw_openprice;
  memcpy(&raw_openprice, &tmp_openprice, sizeof(tmp_openprice));
  if (raw_openprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_openprice(), target);
  }

  // float HighestPrice = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_highestprice = this->_internal_highestprice();
  uint32_t raw_highestprice;
  memcpy(&raw_highestprice, &tmp_highestprice, sizeof(tmp_highestprice));
  if (raw_highestprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_highestprice(), target);
  }

  // float LowestPrice = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowestprice = this->_internal_lowestprice();
  uint32_t raw_lowestprice;
  memcpy(&raw_lowestprice, &tmp_lowestprice, sizeof(tmp_lowestprice));
  if (raw_lowestprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_lowestprice(), target);
  }

  // int32 Volume = 12;
  if (this->_internal_volume() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_volume(), target);
  }

  // double Turnover = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turnover = this->_internal_turnover();
  uint64_t raw_turnover;
  memcpy(&raw_turnover, &tmp_turnover, sizeof(tmp_turnover));
  if (raw_turnover != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_turnover(), target);
  }

  // double OpenInterest = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_openinterest = this->_internal_openinterest();
  uint64_t raw_openinterest;
  memcpy(&raw_openinterest, &tmp_openinterest, sizeof(tmp_openinterest));
  if (raw_openinterest != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_openinterest(), target);
  }

  // float ClosePrice = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_closeprice = this->_internal_closeprice();
  uint32_t raw_closeprice;
  memcpy(&raw_closeprice, &tmp_closeprice, sizeof(tmp_closeprice));
  if (raw_closeprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_closeprice(), target);
  }

  // float SettlementPrice = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_settlementprice = this->_internal_settlementprice();
  uint32_t raw_settlementprice;
  memcpy(&raw_settlementprice, &tmp_settlementprice, sizeof(tmp_settlementprice));
  if (raw_settlementprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_settlementprice(), target);
  }

  // float UpperLimitPrice = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_upperlimitprice = this->_internal_upperlimitprice();
  uint32_t raw_upperlimitprice;
  memcpy(&raw_upperlimitprice, &tmp_upperlimitprice, sizeof(tmp_upperlimitprice));
  if (raw_upperlimitprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_upperlimitprice(), target);
  }

  // float LowerLimitPrice = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowerlimitprice = this->_internal_lowerlimitprice();
  uint32_t raw_lowerlimitprice;
  memcpy(&raw_lowerlimitprice, &tmp_lowerlimitprice, sizeof(tmp_lowerlimitprice));
  if (raw_lowerlimitprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_lowerlimitprice(), target);
  }

  // double PreDelta = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_predelta = this->_internal_predelta();
  uint64_t raw_predelta;
  memcpy(&raw_predelta, &tmp_predelta, sizeof(tmp_predelta));
  if (raw_predelta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(19, this->_internal_predelta(), target);
  }

  // double CurrDelta = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_currdelta = this->_internal_currdelta();
  uint64_t raw_currdelta;
  memcpy(&raw_currdelta, &tmp_currdelta, sizeof(tmp_currdelta));
  if (raw_currdelta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(20, this->_internal_currdelta(), target);
  }

  // string UpdateTime = 21;
  if (!this->_internal_updatetime().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_updatetime().data(), static_cast<int>(this->_internal_updatetime().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.UpdateTime");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_updatetime(), target);
  }

  // int32 UpdateMillisec = 22;
  if (this->_internal_updatemillisec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(22, this->_internal_updatemillisec(), target);
  }

  // float BidPrice1 = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice1 = this->_internal_bidprice1();
  uint32_t raw_bidprice1;
  memcpy(&raw_bidprice1, &tmp_bidprice1, sizeof(tmp_bidprice1));
  if (raw_bidprice1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(23, this->_internal_bidprice1(), target);
  }

  // int32 BidVolume1 = 24;
  if (this->_internal_bidvolume1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(24, this->_internal_bidvolume1(), target);
  }

  // float AskPrice1 = 25;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice1 = this->_internal_askprice1();
  uint32_t raw_askprice1;
  memcpy(&raw_askprice1, &tmp_askprice1, sizeof(tmp_askprice1));
  if (raw_askprice1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_askprice1(), target);
  }

  // int32 AskVolume1 = 26;
  if (this->_internal_askvolume1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(26, this->_internal_askvolume1(), target);
  }

  // float BidPrice2 = 27;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice2 = this->_internal_bidprice2();
  uint32_t raw_bidprice2;
  memcpy(&raw_bidprice2, &tmp_bidprice2, sizeof(tmp_bidprice2));
  if (raw_bidprice2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(27, this->_internal_bidprice2(), target);
  }

  // int32 BidVolume2 = 28;
  if (this->_internal_bidvolume2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(28, this->_internal_bidvolume2(), target);
  }

  // float AskPrice2 = 29;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice2 = this->_internal_askprice2();
  uint32_t raw_askprice2;
  memcpy(&raw_askprice2, &tmp_askprice2, sizeof(tmp_askprice2));
  if (raw_askprice2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(29, this->_internal_askprice2(), target);
  }

  // int32 AskVolume2 = 30;
  if (this->_internal_askvolume2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(30, this->_internal_askvolume2(), target);
  }

  // float BidPrice3 = 31;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice3 = this->_internal_bidprice3();
  uint32_t raw_bidprice3;
  memcpy(&raw_bidprice3, &tmp_bidprice3, sizeof(tmp_bidprice3));
  if (raw_bidprice3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_bidprice3(), target);
  }

  // int32 BidVolume3 = 32;
  if (this->_internal_bidvolume3() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(32, this->_internal_bidvolume3(), target);
  }

  // float AskPrice3 = 33;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice3 = this->_internal_askprice3();
  uint32_t raw_askprice3;
  memcpy(&raw_askprice3, &tmp_askprice3, sizeof(tmp_askprice3));
  if (raw_askprice3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(33, this->_internal_askprice3(), target);
  }

  // int32 AskVolume3 = 34;
  if (this->_internal_askvolume3() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(34, this->_internal_askvolume3(), target);
  }

  // float BidPrice4 = 35;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice4 = this->_internal_bidprice4();
  uint32_t raw_bidprice4;
  memcpy(&raw_bidprice4, &tmp_bidprice4, sizeof(tmp_bidprice4));
  if (raw_bidprice4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(35, this->_internal_bidprice4(), target);
  }

  // int32 BidVolume4 = 36;
  if (this->_internal_bidvolume4() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(36, this->_internal_bidvolume4(), target);
  }

  // float AskPrice4 = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice4 = this->_internal_askprice4();
  uint32_t raw_askprice4;
  memcpy(&raw_askprice4, &tmp_askprice4, sizeof(tmp_askprice4));
  if (raw_askprice4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_askprice4(), target);
  }

  // int32 AskVolume4 = 38;
  if (this->_internal_askvolume4() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(38, this->_internal_askvolume4(), target);
  }

  // float BidPrice5 = 39;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice5 = this->_internal_bidprice5();
  uint32_t raw_bidprice5;
  memcpy(&raw_bidprice5, &tmp_bidprice5, sizeof(tmp_bidprice5));
  if (raw_bidprice5 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(39, this->_internal_bidprice5(), target);
  }

  // int32 BidVolume5 = 40;
  if (this->_internal_bidvolume5() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_bidvolume5(), target);
  }

  // float AskPrice5 = 42;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice5 = this->_internal_askprice5();
  uint32_t raw_askprice5;
  memcpy(&raw_askprice5, &tmp_askprice5, sizeof(tmp_askprice5));
  if (raw_askprice5 != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(42, this->_internal_askprice5(), target);
  }

  // int32 AskVolume5 = 43;
  if (this->_internal_askvolume5() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(43, this->_internal_askvolume5(), target);
  }

  // float AveragePrice = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_averageprice = this->_internal_averageprice();
  uint32_t raw_averageprice;
  memcpy(&raw_averageprice, &tmp_averageprice, sizeof(tmp_averageprice));
  if (raw_averageprice != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(44, this->_internal_averageprice(), target);
  }

  // string ActionDay = 45;
  if (!this->_internal_actionday().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_actionday().data(), static_cast<int>(this->_internal_actionday().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "dat.TickData.ActionDay");
    target = stream->WriteStringMaybeAliased(
        45, this->_internal_actionday(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dat.TickData)
  return target;
}

size_t TickData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dat.TickData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string TradingDay = 1;
  if (!this->_internal_tradingday().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tradingday());
  }

  // string InstrumentID = 2;
  if (!this->_internal_instrumentid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_instrumentid());
  }

  // string ExchangeID = 3;
  if (!this->_internal_exchangeid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_exchangeid());
  }

  // string ExchangeInstID = 4;
  if (!this->_internal_exchangeinstid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_exchangeinstid());
  }

  // string UpdateTime = 21;
  if (!this->_internal_updatetime().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_updatetime());
  }

  // string ActionDay = 45;
  if (!this->_internal_actionday().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_actionday());
  }

  // float LastPrice = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lastprice = this->_internal_lastprice();
  uint32_t raw_lastprice;
  memcpy(&raw_lastprice, &tmp_lastprice, sizeof(tmp_lastprice));
  if (raw_lastprice != 0) {
    total_size += 1 + 4;
  }

  // float PreSettlementPrice = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_presettlementprice = this->_internal_presettlementprice();
  uint32_t raw_presettlementprice;
  memcpy(&raw_presettlementprice, &tmp_presettlementprice, sizeof(tmp_presettlementprice));
  if (raw_presettlementprice != 0) {
    total_size += 1 + 4;
  }

  // float PreClosePrice = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_precloseprice = this->_internal_precloseprice();
  uint32_t raw_precloseprice;
  memcpy(&raw_precloseprice, &tmp_precloseprice, sizeof(tmp_precloseprice));
  if (raw_precloseprice != 0) {
    total_size += 1 + 4;
  }

  // float PreOpenInterest = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_preopeninterest = this->_internal_preopeninterest();
  uint32_t raw_preopeninterest;
  memcpy(&raw_preopeninterest, &tmp_preopeninterest, sizeof(tmp_preopeninterest));
  if (raw_preopeninterest != 0) {
    total_size += 1 + 4;
  }

  // float OpenPrice = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_openprice = this->_internal_openprice();
  uint32_t raw_openprice;
  memcpy(&raw_openprice, &tmp_openprice, sizeof(tmp_openprice));
  if (raw_openprice != 0) {
    total_size += 1 + 4;
  }

  // float HighestPrice = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_highestprice = this->_internal_highestprice();
  uint32_t raw_highestprice;
  memcpy(&raw_highestprice, &tmp_highestprice, sizeof(tmp_highestprice));
  if (raw_highestprice != 0) {
    total_size += 1 + 4;
  }

  // float LowestPrice = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowestprice = this->_internal_lowestprice();
  uint32_t raw_lowestprice;
  memcpy(&raw_lowestprice, &tmp_lowestprice, sizeof(tmp_lowestprice));
  if (raw_lowestprice != 0) {
    total_size += 1 + 4;
  }

  // int32 Volume = 12;
  if (this->_internal_volume() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_volume());
  }

  // double Turnover = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turnover = this->_internal_turnover();
  uint64_t raw_turnover;
  memcpy(&raw_turnover, &tmp_turnover, sizeof(tmp_turnover));
  if (raw_turnover != 0) {
    total_size += 1 + 8;
  }

  // double OpenInterest = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_openinterest = this->_internal_openinterest();
  uint64_t raw_openinterest;
  memcpy(&raw_openinterest, &tmp_openinterest, sizeof(tmp_openinterest));
  if (raw_openinterest != 0) {
    total_size += 1 + 8;
  }

  // float ClosePrice = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_closeprice = this->_internal_closeprice();
  uint32_t raw_closeprice;
  memcpy(&raw_closeprice, &tmp_closeprice, sizeof(tmp_closeprice));
  if (raw_closeprice != 0) {
    total_size += 1 + 4;
  }

  // float SettlementPrice = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_settlementprice = this->_internal_settlementprice();
  uint32_t raw_settlementprice;
  memcpy(&raw_settlementprice, &tmp_settlementprice, sizeof(tmp_settlementprice));
  if (raw_settlementprice != 0) {
    total_size += 2 + 4;
  }

  // float UpperLimitPrice = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_upperlimitprice = this->_internal_upperlimitprice();
  uint32_t raw_upperlimitprice;
  memcpy(&raw_upperlimitprice, &tmp_upperlimitprice, sizeof(tmp_upperlimitprice));
  if (raw_upperlimitprice != 0) {
    total_size += 2 + 4;
  }

  // float LowerLimitPrice = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowerlimitprice = this->_internal_lowerlimitprice();
  uint32_t raw_lowerlimitprice;
  memcpy(&raw_lowerlimitprice, &tmp_lowerlimitprice, sizeof(tmp_lowerlimitprice));
  if (raw_lowerlimitprice != 0) {
    total_size += 2 + 4;
  }

  // double PreDelta = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_predelta = this->_internal_predelta();
  uint64_t raw_predelta;
  memcpy(&raw_predelta, &tmp_predelta, sizeof(tmp_predelta));
  if (raw_predelta != 0) {
    total_size += 2 + 8;
  }

  // double CurrDelta = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_currdelta = this->_internal_currdelta();
  uint64_t raw_currdelta;
  memcpy(&raw_currdelta, &tmp_currdelta, sizeof(tmp_currdelta));
  if (raw_currdelta != 0) {
    total_size += 2 + 8;
  }

  // int32 UpdateMillisec = 22;
  if (this->_internal_updatemillisec() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_updatemillisec());
  }

  // float BidPrice1 = 23;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice1 = this->_internal_bidprice1();
  uint32_t raw_bidprice1;
  memcpy(&raw_bidprice1, &tmp_bidprice1, sizeof(tmp_bidprice1));
  if (raw_bidprice1 != 0) {
    total_size += 2 + 4;
  }

  // int32 BidVolume1 = 24;
  if (this->_internal_bidvolume1() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_bidvolume1());
  }

  // float AskPrice1 = 25;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice1 = this->_internal_askprice1();
  uint32_t raw_askprice1;
  memcpy(&raw_askprice1, &tmp_askprice1, sizeof(tmp_askprice1));
  if (raw_askprice1 != 0) {
    total_size += 2 + 4;
  }

  // int32 AskVolume1 = 26;
  if (this->_internal_askvolume1() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_askvolume1());
  }

  // float BidPrice2 = 27;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice2 = this->_internal_bidprice2();
  uint32_t raw_bidprice2;
  memcpy(&raw_bidprice2, &tmp_bidprice2, sizeof(tmp_bidprice2));
  if (raw_bidprice2 != 0) {
    total_size += 2 + 4;
  }

  // int32 BidVolume2 = 28;
  if (this->_internal_bidvolume2() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_bidvolume2());
  }

  // float AskPrice2 = 29;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice2 = this->_internal_askprice2();
  uint32_t raw_askprice2;
  memcpy(&raw_askprice2, &tmp_askprice2, sizeof(tmp_askprice2));
  if (raw_askprice2 != 0) {
    total_size += 2 + 4;
  }

  // int32 AskVolume2 = 30;
  if (this->_internal_askvolume2() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_askvolume2());
  }

  // float BidPrice3 = 31;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice3 = this->_internal_bidprice3();
  uint32_t raw_bidprice3;
  memcpy(&raw_bidprice3, &tmp_bidprice3, sizeof(tmp_bidprice3));
  if (raw_bidprice3 != 0) {
    total_size += 2 + 4;
  }

  // int32 BidVolume3 = 32;
  if (this->_internal_bidvolume3() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_bidvolume3());
  }

  // float AskPrice3 = 33;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice3 = this->_internal_askprice3();
  uint32_t raw_askprice3;
  memcpy(&raw_askprice3, &tmp_askprice3, sizeof(tmp_askprice3));
  if (raw_askprice3 != 0) {
    total_size += 2 + 4;
  }

  // int32 AskVolume3 = 34;
  if (this->_internal_askvolume3() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_askvolume3());
  }

  // float BidPrice4 = 35;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice4 = this->_internal_bidprice4();
  uint32_t raw_bidprice4;
  memcpy(&raw_bidprice4, &tmp_bidprice4, sizeof(tmp_bidprice4));
  if (raw_bidprice4 != 0) {
    total_size += 2 + 4;
  }

  // int32 BidVolume4 = 36;
  if (this->_internal_bidvolume4() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_bidvolume4());
  }

  // float AskPrice4 = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice4 = this->_internal_askprice4();
  uint32_t raw_askprice4;
  memcpy(&raw_askprice4, &tmp_askprice4, sizeof(tmp_askprice4));
  if (raw_askprice4 != 0) {
    total_size += 2 + 4;
  }

  // int32 AskVolume4 = 38;
  if (this->_internal_askvolume4() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_askvolume4());
  }

  // float BidPrice5 = 39;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice5 = this->_internal_bidprice5();
  uint32_t raw_bidprice5;
  memcpy(&raw_bidprice5, &tmp_bidprice5, sizeof(tmp_bidprice5));
  if (raw_bidprice5 != 0) {
    total_size += 2 + 4;
  }

  // int32 BidVolume5 = 40;
  if (this->_internal_bidvolume5() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_bidvolume5());
  }

  // float AskPrice5 = 42;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice5 = this->_internal_askprice5();
  uint32_t raw_askprice5;
  memcpy(&raw_askprice5, &tmp_askprice5, sizeof(tmp_askprice5));
  if (raw_askprice5 != 0) {
    total_size += 2 + 4;
  }

  // int32 AskVolume5 = 43;
  if (this->_internal_askvolume5() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_askvolume5());
  }

  // float AveragePrice = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_averageprice = this->_internal_averageprice();
  uint32_t raw_averageprice;
  memcpy(&raw_averageprice, &tmp_averageprice, sizeof(tmp_averageprice));
  if (raw_averageprice != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TickData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TickData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TickData::GetClassData() const { return &_class_data_; }

void TickData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TickData *>(to)->MergeFrom(
      static_cast<const TickData &>(from));
}


void TickData::MergeFrom(const TickData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dat.TickData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_tradingday().empty()) {
    _internal_set_tradingday(from._internal_tradingday());
  }
  if (!from._internal_instrumentid().empty()) {
    _internal_set_instrumentid(from._internal_instrumentid());
  }
  if (!from._internal_exchangeid().empty()) {
    _internal_set_exchangeid(from._internal_exchangeid());
  }
  if (!from._internal_exchangeinstid().empty()) {
    _internal_set_exchangeinstid(from._internal_exchangeinstid());
  }
  if (!from._internal_updatetime().empty()) {
    _internal_set_updatetime(from._internal_updatetime());
  }
  if (!from._internal_actionday().empty()) {
    _internal_set_actionday(from._internal_actionday());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lastprice = from._internal_lastprice();
  uint32_t raw_lastprice;
  memcpy(&raw_lastprice, &tmp_lastprice, sizeof(tmp_lastprice));
  if (raw_lastprice != 0) {
    _internal_set_lastprice(from._internal_lastprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_presettlementprice = from._internal_presettlementprice();
  uint32_t raw_presettlementprice;
  memcpy(&raw_presettlementprice, &tmp_presettlementprice, sizeof(tmp_presettlementprice));
  if (raw_presettlementprice != 0) {
    _internal_set_presettlementprice(from._internal_presettlementprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_precloseprice = from._internal_precloseprice();
  uint32_t raw_precloseprice;
  memcpy(&raw_precloseprice, &tmp_precloseprice, sizeof(tmp_precloseprice));
  if (raw_precloseprice != 0) {
    _internal_set_precloseprice(from._internal_precloseprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_preopeninterest = from._internal_preopeninterest();
  uint32_t raw_preopeninterest;
  memcpy(&raw_preopeninterest, &tmp_preopeninterest, sizeof(tmp_preopeninterest));
  if (raw_preopeninterest != 0) {
    _internal_set_preopeninterest(from._internal_preopeninterest());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_openprice = from._internal_openprice();
  uint32_t raw_openprice;
  memcpy(&raw_openprice, &tmp_openprice, sizeof(tmp_openprice));
  if (raw_openprice != 0) {
    _internal_set_openprice(from._internal_openprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_highestprice = from._internal_highestprice();
  uint32_t raw_highestprice;
  memcpy(&raw_highestprice, &tmp_highestprice, sizeof(tmp_highestprice));
  if (raw_highestprice != 0) {
    _internal_set_highestprice(from._internal_highestprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowestprice = from._internal_lowestprice();
  uint32_t raw_lowestprice;
  memcpy(&raw_lowestprice, &tmp_lowestprice, sizeof(tmp_lowestprice));
  if (raw_lowestprice != 0) {
    _internal_set_lowestprice(from._internal_lowestprice());
  }
  if (from._internal_volume() != 0) {
    _internal_set_volume(from._internal_volume());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turnover = from._internal_turnover();
  uint64_t raw_turnover;
  memcpy(&raw_turnover, &tmp_turnover, sizeof(tmp_turnover));
  if (raw_turnover != 0) {
    _internal_set_turnover(from._internal_turnover());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_openinterest = from._internal_openinterest();
  uint64_t raw_openinterest;
  memcpy(&raw_openinterest, &tmp_openinterest, sizeof(tmp_openinterest));
  if (raw_openinterest != 0) {
    _internal_set_openinterest(from._internal_openinterest());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_closeprice = from._internal_closeprice();
  uint32_t raw_closeprice;
  memcpy(&raw_closeprice, &tmp_closeprice, sizeof(tmp_closeprice));
  if (raw_closeprice != 0) {
    _internal_set_closeprice(from._internal_closeprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_settlementprice = from._internal_settlementprice();
  uint32_t raw_settlementprice;
  memcpy(&raw_settlementprice, &tmp_settlementprice, sizeof(tmp_settlementprice));
  if (raw_settlementprice != 0) {
    _internal_set_settlementprice(from._internal_settlementprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_upperlimitprice = from._internal_upperlimitprice();
  uint32_t raw_upperlimitprice;
  memcpy(&raw_upperlimitprice, &tmp_upperlimitprice, sizeof(tmp_upperlimitprice));
  if (raw_upperlimitprice != 0) {
    _internal_set_upperlimitprice(from._internal_upperlimitprice());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lowerlimitprice = from._internal_lowerlimitprice();
  uint32_t raw_lowerlimitprice;
  memcpy(&raw_lowerlimitprice, &tmp_lowerlimitprice, sizeof(tmp_lowerlimitprice));
  if (raw_lowerlimitprice != 0) {
    _internal_set_lowerlimitprice(from._internal_lowerlimitprice());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_predelta = from._internal_predelta();
  uint64_t raw_predelta;
  memcpy(&raw_predelta, &tmp_predelta, sizeof(tmp_predelta));
  if (raw_predelta != 0) {
    _internal_set_predelta(from._internal_predelta());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_currdelta = from._internal_currdelta();
  uint64_t raw_currdelta;
  memcpy(&raw_currdelta, &tmp_currdelta, sizeof(tmp_currdelta));
  if (raw_currdelta != 0) {
    _internal_set_currdelta(from._internal_currdelta());
  }
  if (from._internal_updatemillisec() != 0) {
    _internal_set_updatemillisec(from._internal_updatemillisec());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice1 = from._internal_bidprice1();
  uint32_t raw_bidprice1;
  memcpy(&raw_bidprice1, &tmp_bidprice1, sizeof(tmp_bidprice1));
  if (raw_bidprice1 != 0) {
    _internal_set_bidprice1(from._internal_bidprice1());
  }
  if (from._internal_bidvolume1() != 0) {
    _internal_set_bidvolume1(from._internal_bidvolume1());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice1 = from._internal_askprice1();
  uint32_t raw_askprice1;
  memcpy(&raw_askprice1, &tmp_askprice1, sizeof(tmp_askprice1));
  if (raw_askprice1 != 0) {
    _internal_set_askprice1(from._internal_askprice1());
  }
  if (from._internal_askvolume1() != 0) {
    _internal_set_askvolume1(from._internal_askvolume1());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice2 = from._internal_bidprice2();
  uint32_t raw_bidprice2;
  memcpy(&raw_bidprice2, &tmp_bidprice2, sizeof(tmp_bidprice2));
  if (raw_bidprice2 != 0) {
    _internal_set_bidprice2(from._internal_bidprice2());
  }
  if (from._internal_bidvolume2() != 0) {
    _internal_set_bidvolume2(from._internal_bidvolume2());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice2 = from._internal_askprice2();
  uint32_t raw_askprice2;
  memcpy(&raw_askprice2, &tmp_askprice2, sizeof(tmp_askprice2));
  if (raw_askprice2 != 0) {
    _internal_set_askprice2(from._internal_askprice2());
  }
  if (from._internal_askvolume2() != 0) {
    _internal_set_askvolume2(from._internal_askvolume2());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice3 = from._internal_bidprice3();
  uint32_t raw_bidprice3;
  memcpy(&raw_bidprice3, &tmp_bidprice3, sizeof(tmp_bidprice3));
  if (raw_bidprice3 != 0) {
    _internal_set_bidprice3(from._internal_bidprice3());
  }
  if (from._internal_bidvolume3() != 0) {
    _internal_set_bidvolume3(from._internal_bidvolume3());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice3 = from._internal_askprice3();
  uint32_t raw_askprice3;
  memcpy(&raw_askprice3, &tmp_askprice3, sizeof(tmp_askprice3));
  if (raw_askprice3 != 0) {
    _internal_set_askprice3(from._internal_askprice3());
  }
  if (from._internal_askvolume3() != 0) {
    _internal_set_askvolume3(from._internal_askvolume3());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice4 = from._internal_bidprice4();
  uint32_t raw_bidprice4;
  memcpy(&raw_bidprice4, &tmp_bidprice4, sizeof(tmp_bidprice4));
  if (raw_bidprice4 != 0) {
    _internal_set_bidprice4(from._internal_bidprice4());
  }
  if (from._internal_bidvolume4() != 0) {
    _internal_set_bidvolume4(from._internal_bidvolume4());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice4 = from._internal_askprice4();
  uint32_t raw_askprice4;
  memcpy(&raw_askprice4, &tmp_askprice4, sizeof(tmp_askprice4));
  if (raw_askprice4 != 0) {
    _internal_set_askprice4(from._internal_askprice4());
  }
  if (from._internal_askvolume4() != 0) {
    _internal_set_askvolume4(from._internal_askvolume4());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bidprice5 = from._internal_bidprice5();
  uint32_t raw_bidprice5;
  memcpy(&raw_bidprice5, &tmp_bidprice5, sizeof(tmp_bidprice5));
  if (raw_bidprice5 != 0) {
    _internal_set_bidprice5(from._internal_bidprice5());
  }
  if (from._internal_bidvolume5() != 0) {
    _internal_set_bidvolume5(from._internal_bidvolume5());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_askprice5 = from._internal_askprice5();
  uint32_t raw_askprice5;
  memcpy(&raw_askprice5, &tmp_askprice5, sizeof(tmp_askprice5));
  if (raw_askprice5 != 0) {
    _internal_set_askprice5(from._internal_askprice5());
  }
  if (from._internal_askvolume5() != 0) {
    _internal_set_askvolume5(from._internal_askvolume5());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_averageprice = from._internal_averageprice();
  uint32_t raw_averageprice;
  memcpy(&raw_averageprice, &tmp_averageprice, sizeof(tmp_averageprice));
  if (raw_averageprice != 0) {
    _internal_set_averageprice(from._internal_averageprice());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TickData::CopyFrom(const TickData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dat.TickData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TickData::IsInitialized() const {
  return true;
}

void TickData::InternalSwap(TickData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &tradingday_, lhs_arena,
      &other->tradingday_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &instrumentid_, lhs_arena,
      &other->instrumentid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &exchangeid_, lhs_arena,
      &other->exchangeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &exchangeinstid_, lhs_arena,
      &other->exchangeinstid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &updatetime_, lhs_arena,
      &other->updatetime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &actionday_, lhs_arena,
      &other->actionday_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TickData, averageprice_)
      + sizeof(TickData::averageprice_)
      - PROTOBUF_FIELD_OFFSET(TickData, lastprice_)>(
          reinterpret_cast<char*>(&lastprice_),
          reinterpret_cast<char*>(&other->lastprice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TickData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_tick_2eproto_getter, &descriptor_table_tick_2eproto_once,
      file_level_metadata_tick_2eproto[0]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace dat
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::dat::TickData* Arena::CreateMaybeMessage< ::dat::TickData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dat::TickData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
